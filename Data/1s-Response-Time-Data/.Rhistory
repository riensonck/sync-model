library(data.table)
library(car)
library(RMySQL)
library(ini)
library(ggplot2)
library(dplyr)
library(tidybayes)
library(tidyr)
library(modelr)
library(lme4)
library(ggpubr)
################
# GETTING DATA #
################
# database connection
dbconfig <- read.ini("~/.dbconf")$client
con <- with(dbconfig,
dbConnect(RMySQL::MySQL(), host = host, user = user, password = passwd, db = "jenya"))
# get the nonverbal data fits for risk
riskfits_nonverbal <- data.table(dbGetQuery(con,
"SELECT subjid, sessid, noise_prior, logr_prior, noise, logr, LL, BIC, AIC, r2 FROM riskNVfits order by subjid, sessid"
))
riskfits_nonverbal$priors <- with(riskfits_nonverbal, paste0("(", noise_prior, ", ", logr_prior, ")"))
# get the verbal data fits for risk
riskfits_verbal <- data.table(dbGetQuery(con,
"SELECT subjid, sessid, noise_prior, logr_prior, noise, logr, LL, BIC, AIC, r2 FROM riskVfits order by subjid, sessid"
))
riskfits_verbal$priors <- with(riskfits_verbal, paste0("(", noise_prior, ", ", logr_prior, ")"))
# subjid not an int but a factor
riskfits_nonverbal$subjid <- as.factor(riskfits_nonverbal$subjid)
riskfits_verbal$subjid <- as.factor(riskfits_verbal$subjid)
priors = c("P1", "P2", "P3", "P4", "P5", "P6", "P7", "P8", "P9")
p1 <- ggplot(riskfits_nonverbal, aes(x = priors, y = LL)) +
geom_point() +
facet_wrap( ~ subjid, labeller = label_wrap_gen(multi_line=FALSE)) +
theme(axis.text.x = element_text(face="bold",
size=9, angle=90),
axis.text.y = element_text(face="bold",
size=9))
p1
p1 <- ggplot(riskfits_nonverbal, aes(x = priors, y = noise)) +
geom_point() +
facet_wrap( ~ subjid, labeller = label_wrap_gen(multi_line=FALSE)) +
theme(axis.text.x = element_text(face="bold",
size=9, angle=90),
axis.text.y = element_text(face="bold",
size=9))
p1
riskfits_nonverbal
p1 <- ggplot(riskfits_nonverbal, aes(x = priors, y = logr)) +
geom_point() +
facet_wrap( ~ subjid, labeller = label_wrap_gen(multi_line=FALSE)) +
theme(axis.text.x = element_text(face="bold",
size=9, angle=90),
axis.text.y = element_text(face="bold",
size=9))
p1
p1 <- ggplot(riskfits_nonverbal, aes(x = priors, y = noise)) +
geom_point() +
facet_wrap( ~ subjid, labeller = label_wrap_gen(multi_line=FALSE)) +
theme(axis.text.x = element_text(face="bold",
size=9, angle=90),
axis.text.y = element_text(face="bold",
size=9))
p1
p1 <- ggplot(riskfits_verbal, aes(x = priors, y = noise)) +
geom_point() +
facet_wrap( ~ subjid, labeller = label_wrap_gen(multi_line=FALSE)) +
theme(axis.text.x = element_text(face="bold",
size=9, angle=90),
axis.text.y = element_text(face="bold",
size=9))
p1
p1 <- ggplot(riskfits_verbal, aes(x = priors, y = logr)) +
geom_point() +
facet_wrap( ~ subjid, labeller = label_wrap_gen(multi_line=FALSE)) +
theme(axis.text.x = element_text(face="bold",
size=9, angle=90),
axis.text.y = element_text(face="bold",
size=9))
p1
library(ggplot2) # library for plotting
library(ggpubr)
library(dplyr) # library to join dataframes
library(cowplot) # has the function background_grid
library(tidybayes)
library(RColorBrewer) # for color gradient
library(reshape2)
theme_set(theme_tidybayes() + background_grid()) # changing the theme of the plots
################
## Functions  ##
################
##   Source Code: http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/#Helper%20functions
##   Gives count, mean, standard deviation, standard error of the mean, and confidence interval (default 95%).
##   data: a data frame.
##   measurevar: the name of a column that contains the variable to be summarized
##   groupvars: a vector containing names of columns that contain grouping variables
##   na.rm: a boolean that indicates whether to ignore NA's
##   conf.interval: the percent range of the confidence interval (default is 95%)
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
conf.interval=.95, .drop=TRUE) {
library(plyr) # loading plyr locally will mask dplyr globally, and not give rise to conflicting issues
# New version of length which can handle NA's: if na.rm==T, don't count them
length2 <- function (x, na.rm=FALSE) {
if (na.rm) sum(!is.na(x))
else       length(x)
}
# This does the summary. For each group's data frame, return a vector with
# N, mean, and sd
datac <- ddply(data, groupvars, .drop=.drop,
.fun = function(xx, col) {
c(N    = length2(xx[[col]], na.rm=na.rm),
mean = mean   (xx[[col]], na.rm=na.rm),
sd   = sd     (xx[[col]], na.rm=na.rm)
)
},
measurevar
)
# Rename the "mean" column
# loading the library (plyr) and (dplyr) together will give rise to conflicting functions, and this will result in an Error: All arguments must be named
datac <- rename(datac, c("mean" = measurevar))
datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
# Confidence interval multiplier for standard error
# Calculate t-statistic for confidence interval:
# e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
ciMult <- qt(conf.interval/2 + .5, datac$N-1)
datac$ci <- datac$se * ciMult
return(datac)
}
## EZ Diffusion Model
## Code adapted from Eric-Jan Wagenmakers, Han L.J. van der Maas , and Raoul P. P. P. Grasman (2007)
## Gives the parameters of the EZ diffusion model
## theta: theta frequencies to be included as a column in the output dataset of this function
## thres: threshold to be included as a column in the output dataset of this function
## drift: neuron drift to be included as a column in the output dataset of this function
## isi: inter-stimulus interval (isi) to be included as a column in the output dataset of this function
## Pc: the proportion of correct decisions
## VRT: the variance of response times for correct decisions
## MRT: mean response time for correct decisions
## s: scaling parameter, the default vaue equals 0.1
## use.isi: boolean, set TRUE if you want to include the isi as a column in the output dataset of this function
get.vaTer = function(theta, drift, thres,  isi = 0, Pc, VRT, MRT, s = 0.1, use.isi = FALSE){
# The default value for the scaling parameter s equals 0.1
s2 <- s^2
# If Pc equals 0, .5, or 1, the method will not work, and
# an edge correction is required.
if (Pc == 0){
cat("Oops, Pc == 0!\n")
}
if (Pc == 0.5){
cat("Oops, Pc == 0.5!\n")
Pc = 0.5001
}
if (Pc == 1){
cat("Oops, Pc == 1!\n")
}
# The function “qlogis” calculates the logit.
L <- qlogis(Pc)
x <- L*(L*Pc^2 - L*Pc + Pc - 0.5)/VRT
v <- sign(Pc - 0.5) * s * x^(1/4)
# This gives drift rate.
a = s2 * qlogis(Pc)/v
# This gives boundary separation.
y = -v * a/s2
MDT = (a/(2 * v)) * (1 - exp(y))/(1 + exp(y))
Ter = MRT - MDT
# This gives nondecision time.
if(use.isi){ # returns the isi as a column in the dataset
return(c(theta, drift, thres, isi, round(v,4), round(a, 4), round(Ter,4)))
} else {
return(c(theta, drift, thres,round(v,4), round(a, 4), round(Ter,4)))
}
}
time_change <- function(data, thetas, drifts, threshs){
# create an empty dataframe to store the information
df <- vector()
for(th in thetas){
for(thr in threshs){
for(dr in drifts){
sub <- subset(data, theta == th & drift == dr & thres == thr)
d <- density(sub$rt)  # reaction time density plot
d1 <- sign(diff(d$y)/diff(d$x)) # derivative of the density plot
change <- which(diff(d1) != 0) # the timepoints where the density derivative changes sign
df <- rbind(df, c(th, thr, dr, "T1", change[1]))
df <- rbind(df, c(th, thr, dr, "T2", change[2]))
df <- rbind(df, c(th, thr, dr, "T3", change[3]))
}
}
}
return(df)
}
#####################
## Importing Data  ##
#####################
setwd("~/repos/github_sync-model/Data/1s-Response-Time-Data/") # Setting the working directory to the folder containing the data
#setwd("~/repos/github_sync-model/Data/Lapsing-Bounds-Data/") # Setting the working directory to the folder containing the data
files <-list.files(pattern="*.csv")   # collecting all the .csv files in the current working directory
data <- do.call(rbind, lapply(files, function(x){
df <- read.csv(x)
str <- gsub("[^0-9]", "",  x) # extracting the numbers from the file name
# some files have a longer str than others, because the theta frequency values range from 1-20
# TODO: change the Python code, to save the files names as ex. 01 instead of 1 for theta.
if (nchar(str) == 7){ # extracting theta values 1 to 9
df$theta <- substr(str, start = 2, stop = 2) # extracting the theta frequency value
df$thres <- substr(str, start = 5, stop = 5) #  extracting the threshold value
df$drift <- substr(str, start = 6, stop = 6) # extracting the drift rate of the neurons (inverse of the drift of the drift diffusion model)
} else if (nchar(str == 8)){ # extracting theta values 10 to 20
df$theta <- substr(str, start = 2, stop = 3) # extracting the theta frequency value
df$thres <- substr(str, start = 6, stop = 6) #  extracting the threshold value
df$drift <- substr(str, start = 7, stop = 7) # extracting the drift rate of the neurons (inverse of the drift of the drift diffusion model)
} else {
print("file: " + str(x) + " not included")
}
return(df)
}))
####################################
## Summarizing data - without isi ##
####################################
# used for the plots without isi
# including the isi column in the dataset would result in extra points being plotted for each isi in many plots, which might make some plot interpretations harder.
# Summarizing the RT data
RT_summary <- summarySE(data, measurevar = "rt", groupvars = c("theta", "drift", "thres"))
names(RT_summary) <- c("theta", "drift", "thres", "N", "RT", "RT_sd", "RT_se", "RT_ci")
# Summarizing the accuracy data
ACC_summary <- summarySE(data, measurevar = "accuracy", groupvars = c("theta", "drift", "thres"))
names(ACC_summary) <- c("theta", "drift", "thres", "N", "ACC", "ACC_sd", "ACC_se", "ACC_ci")
# Summarizing and transforming to drift v, boundary a, and nondecision-time Ter
EZ_data <- matrix(ncol=6, nrow = 112) # nrows needs to be equal to the amount of rows in RT_summary
MRT <- ddply(data, .(theta, drift, thres) , summarize, mean = mean(rt)) # mean response time for correct and uncorrect decisions for each theta
Pc <- ddply(data, .(theta, drift, thres) , summarize, mean = mean(accuracy)) # Pc, proportion of correct decisions
VRT <- ddply(data, .(theta, drift, thres) , summarize, sd = sd(accuracy)) # VRT, variance of response times for correct decisions
for (i in 1:nrow(Pc)){
vaTer <- get.vaTer(theta = Pc$theta[i], drift = Pc$drift[i], thres = Pc$thres[i], Pc = Pc$mean[i], VRT = VRT$sd[i], MRT = MRT$mean[i])
EZ_data[i,] <- vaTer
}
colnames(EZ_data) <- c("theta", "drift", "thres", "v", "a", "Ter") # v - Mean drift rate, a - Boundary separation, Ter - Mean of the nondecision component of processing
EZ_data <- data.frame(EZ_data)
# all columns are of class factor, have to change them to the numeric class. Changing from factor to numeric is meaningless in R,
# and R will just give each factor a numeric postiion value, so the real value is lost. Using a different way:
EZ_data$theta <- as.numeric(levels(EZ_data$theta))[EZ_data$theta]
EZ_data$v <- as.numeric(levels(EZ_data$v))[EZ_data$v]
EZ_data$a <- as.numeric(levels(EZ_data$a))[EZ_data$a]
EZ_data$Ter <- as.numeric(levels(EZ_data$Ter))[EZ_data$Ter]
# merging together
summary <- left_join(RT_summary, ACC_summary, by = c("theta", "drift", "thres"))
summary$theta <- as.numeric(summary$theta)
summary <- left_join(summary, EZ_data, by = c("theta", "drift", "thres"))
##################################
## Summarizing data - with isi ##
#################################
# used for the plots with isi
# Summarizing the RT data
RT_summary <- summarySE(data, measurevar = "rt", groupvars = c("theta", "drift", "thres", "isi"))
names(RT_summary) <- c("theta", "drift", "thres", "isi", "N", "RT", "RT_sd", "RT_se", "RT_ci")
# Summarizing the accuracy data
ACC_summary <- summarySE(data, measurevar = "accuracy", groupvars = c("theta", "drift", "thres", "isi"))
names(ACC_summary) <- c("theta", "drift", "thres", "isi", "N", "ACC", "ACC_sd", "ACC_se", "ACC_ci")
# Summarizing and transforming to drift v, boundary a, and nondecision-time Ter
EZ_data <- matrix(ncol=7, nrow = 7040)
MRT <- ddply(data, .(theta, drift, thres, isi) , summarize, mean = mean(rt)) # mean response time for correct and uncorrect decisions for each theta
Pc <- ddply(data, .(theta, drift, thres, isi) , summarize, mean = mean(accuracy)) # Pc, proportion of correct decisions
VRT <- ddply(data, .(theta, drift, thres, isi) , summarize, sd = sd(accuracy)) # VRT, variance of response times for correct decisions
for (i in 1:nrow(Pc)){
vaTer <- get.vaTer(Pc$theta[i], Pc$drift[i], Pc$thres[i], Pc$isi[i], Pc$mean[i], VRT$sd[i], MRT$mean[i], use.isi = TRUE)
EZ_data[i,] <- vaTer
}
colnames(EZ_data) <- c("theta", "drift", "thres", "isi", "v", "a", "Ter") # v - Mean drift rate, a - Boundary separation, Ter - Mean of the nondecision component of processing
EZ_data <- data.frame(EZ_data)
# all columns are of class factor, have to change them to the numeric class. Changing from factor to numeric is meaningless in R,
# and R will just give each factor a numeric postiion value, so the real value is lost. Using a different way:
EZ_data$theta <- as.numeric(levels(EZ_data$theta))[EZ_data$theta]
EZ_data$v <- as.numeric(levels(EZ_data$v))[EZ_data$v]
EZ_data$isi <- as.numeric(levels(EZ_data$isi))[EZ_data$isi]
EZ_data$a <- as.numeric(levels(EZ_data$a))[EZ_data$a]
EZ_data$Ter <- as.numeric(levels(EZ_data$Ter))[EZ_data$Ter]
summary_isi <- left_join(RT_summary, ACC_summary, by = c("theta", "drift", "thres", "isi"))
summary_isi$theta <- as.numeric(summary_isi$theta)
summary_isi <- left_join(summary_isi, EZ_data, by = c("theta", "drift", "thres", "isi"))
thetas <- sort(unique(as.numeric(data$theta)))
drifts <- sort(unique(as.numeric(data$drift)))
threshs <- sort(unique(as.numeric(data$thres)))
summary_change <- time_change(data, thetas, drifts, threshs)
summary_change <- as.data.frame(summary_change)
colnames(summary_change) <- c("theta", "thres", "drift", "peak_trough", "timepoint")
summary_change$theta <- as.numeric(levels(summary_change$theta))[summary_change$theta]
summary_change$timepoint <- as.numeric(levels(summary_change$timepoint))[summary_change$timepoint]
p2 <- ggplot(summary_change, aes(x = peak_trough, y = timepoint, group = factor(theta), color= factor(theta))) +
facet_grid(cols = vars(drift), rows = vars(thres), labeller = label_both) +
geom_point() +
geom_line(position = position_dodge(0.1)) +
labs(title = 'RT Distribution ~ theta, drift, threshold 3', x='reaction time', color = "theta")
p2
sub <- subset(data, theta == 5 & drift == 1 & thres == 3)
sub1 <- subset(data, theta == 5 & drift == 1 & thres == 4)
length(sub$rt)
length(sub1$rt)
p3 <- ggplot(summary_change, aes(x = peak_trough, y = timepoint, group = factor(theta), color= factor(theta))) +
facet_grid(cols = vars(drift), rows = vars(thres), labeller = label_both) +
geom_point() +
#geom_line(position = position_dodge(0.1)) +
labs(title = 'RT Distribution ~ theta, drift, threshold 3', x='reaction time', color = "theta")
p3
p2 <- ggplot(summary_change, aes(x = peak_trough, y = timepoint, group = factor(theta), color= factor(theta))) +
facet_grid(cols = vars(drift), rows = vars(thres), labeller = label_both) +
geom_point(position = position_dodge(0.1)) +
#geom_line(position = position_dodge(0.1)) +
labs(title = 'RT Distribution ~ theta, drift, threshold 3', x='reaction time', color = "theta")
p2
p2 + theme_dark()
p2 + theme_linedraw()
data$theta <- factor(data$theta, levels = c("2","3","4","5","6","7","8","9","10","11","12","13","14","15"))
p2 <- ggplot(data, aes(x = rt, color= theta)) +
facet_grid(cols = vars(drift), rows = vars(isi), labeller = label_both) +
geom_density() +
labs(title = 'RT Distribution ~ theta, drift, threshold 3', x='reaction time', color = "theta")
p2
p2 <- ggplot(data, aes(x = rt, color= theta)) +
facet_grid(cols = vars(drift), rows = vars(thres), labeller = label_both) +
geom_density() +
labs(title = 'RT Distribution ~ theta, drift, threshold 3', x='reaction time', color = "theta")
p2
s2 <- subset(data, drift == 1)
p2 <- ggplot(data, aes(x = rt, color= theta)) +
facet_grid(cols = vars(thres), rows = vars(isi), labeller = label_both) +
geom_density() +
labs(title = 'RT Distribution ~ theta, drift 1, threshold', x='reaction time', color = "theta")
p2
ggsave(paste0('~/repos/github_sync-model/Images/1s-Response-Time/p2-drift1','.jpg'),plot=p2, units = 'in', width=14, height =20)
p2 <- ggplot(summary_change, aes(x = peak_trough, y = timepoint, group = factor(theta), color= factor(theta))) +
facet_grid(cols = vars(drift), rows = vars(thres), labeller = label_both) +
geom_point(position = position_dodge(0.1)) +
#geom_line(position = position_dodge(0.1)) +
labs(title = 'RT Distribution ~ theta, drift, threshold 3', x='reaction time', color = "theta")
p2
p2 <- ggplot(summary_change, aes(x = peak_trough, y = timepoint, group = factor(theta), color= factor(theta))) +
facet_grid(cols = vars(drift), rows = vars(thres), labeller = label_both) +
geom_point(position = position_dodge(0.1)) +
#geom_line(position = position_dodge(0.1)) +
labs(title = 'RT Distribution ~ theta, drift, threshold 3', x='reaction time', color = "theta") +
theme_linedraw()
p2
p2 <- ggplot(summary_change, aes(x = peak_trough, y = timepoint, group = factor(theta), color= factor(theta))) +
facet_grid(cols = vars(drift), rows = vars(thres), labeller = label_both) +
geom_point(position = position_dodge(0.1)) +
#geom_line(position = position_dodge(0.1)) +
labs(title = 'Time-step change', x='peak-trough', y ="time-step", color = "theta") +
theme_linedraw()
p2
p2 <- ggplot(summary_change, aes(x = peak_trough, y = timepoint, group = factor(theta), color= factor(theta))) +
facet_grid(cols = vars(drift), rows = vars(thres), labeller = label_both) +
geom_point(position = position_dodge(0.1)) +
geom_line(position = position_dodge(0.1)) +
labs(title = 'Time-step change', x='peak-trough', y ="time-step", color = "theta") +
theme_linedraw()
p2
sub2 <- subset(data, theta == 5 | theta == 9)
p2 <- ggplot(sub2, aes(x = rt, color= theta)) +
facet_grid(cols = vars(drift), rows = vars(thres), labeller = label_both) +
geom_density() +
labs(title = 'RT Distribution ~ theta, drift, threshold 3', x='reaction time', color = "theta")
p2
data$theta <- factor(data$theta, levels = c("2","3","4","5","6","7","8","9","10","11","12","13","14","15"))
sub2 <- subset(data, theta == 5 | theta == 9)
p2 <- ggplot(sub2, aes(x = rt, color= theta)) +
facet_grid(cols = vars(drift), rows = vars(thres), labeller = label_both) +
geom_density() +
labs(title = 'RT Distribution ~ theta, drift, threshold', x='reaction time', color = "theta")
p2
sub2 <- subset(summary_change, theta == 15 & theta == 8 & theta == 2)
p2 <- ggplot(sub2, aes(x = peak_trough, y = timepoint, group = factor(theta), color= factor(theta))) +
facet_grid(cols = vars(drift), rows = vars(thres), labeller = label_both) +
geom_point(position = position_dodge(0.1)) +
geom_line(position = position_dodge(0.1)) +
labs(title = 'Time-step change', x='peak-trough', y ="time-step", color = "theta") +
theme_linedraw()
p2
sub2 <- subset(summary_change, theta == 15 | theta == 8 | theta == 2)
p2 <- ggplot(sub2, aes(x = peak_trough, y = timepoint, group = factor(theta), color= factor(theta))) +
facet_grid(cols = vars(drift), rows = vars(thres), labeller = label_both) +
geom_point(position = position_dodge(0.1)) +
geom_line(position = position_dodge(0.1)) +
labs(title = 'Time-step change', x='peak-trough', y ="time-step", color = "theta") +
theme_linedraw()
p2
sub2 <- subset(summary_change, theta == 15 | theta == 8 | theta == 2 | theta == 3)
p2 <- ggplot(sub2, aes(x = peak_trough, y = timepoint, group = factor(theta), color= factor(theta))) +
facet_grid(cols = vars(drift), rows = vars(thres), labeller = label_both) +
geom_point(position = position_dodge(0.1)) +
geom_line(position = position_dodge(0.1)) +
labs(title = 'Time-step change', x='peak-trough', y ="time-step", color = "theta") +
theme_linedraw()
p2
